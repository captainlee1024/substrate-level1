### 摘要

使用点对点网络解决双重支付问题。

### 简介

传统支付模式的弊端

- 不可避免的依赖可信任第三方机构进行中心化管理
- 引入第三方机构带来的交易成本的提高
- 即使引入可信任的第三方机构，仍需要用户做一些额外的事情来保证系统的可信任。

新的思考

- 使用基于密码学的支付系统取代中心化的第三方机构
- 所有用户都能够参与到交易系统的维护中去，来保障系统的安全性

### 交易

付款人使用自己的私钥签名，签名、公钥、金额一起发送给收款人。

收款人接收到之后使用公钥进行签名的验证，确保交易数据来自付款人。

新的问题：

- 如何确保数据是付款人所有的。

如何解决：

- 公开所有的交易记录，所有人可以根据交易记录，从付款人发起的这笔交易一直追溯到他的第一笔交易，这样就能确保本次交易数据（货币）是否有效。

新的问题：

- 如何确定交易顺序，能够让系统中所有的参与者对交易历史追溯的时候达成一致呢

如何解决：

- 时间戳，为交易打上时间戳

### 时间戳服务器

为了能够让所有参与者看到的交易历史是一致的，引入了时间戳服务器。

时间戳服务器为每笔交易打上一个时间戳，把多笔交易打包到一起形成一个区块，时间戳服务器计算出这个区块的哈希值，并向大家广播这个哈希值，以此来证明这批交易在之前是存在的。

新的问题：

- 如何实现一个点对点的时间戳服务器

### 工作量证明

工作量证明采取搜索一个数N，使得在取哈希的时候，得到的哈希值以N个 0 bit 开头，平均所需工作量随着N呈指数级增长，而验证只需进行一次哈希运算。

所以可以在整个系统中加入一个随机数，直到使得区块的哈希值满足N比特开头的数被找到的方式实现工作量证明。

篡改区块内的交易记录需要在当前块进行从新计算，计算出块之后还要篡改该块后面的所有区块，直到被篡改的分支块高度超过正常分支的块高。然而大多数人是诚实的，除非能够掌握系统中一半以上的算力，否则认为篡改历史交易记录是不可行的。

随着用户的增多和硬件运算速度的增加，出块的速度加快，为了平衡，工作量证明的难度会使用移动平均数算法来调整，确保出块速度相对稳定。

### 网络

- 新的交易向所有节点广播

  

- 每个节点将新交易收集到一个区块

  

- 每个节点为它的区块寻找工作量证明

  

- 当一个节点找到工作量证明，就向所有节点广播该区块

  

- 节点只有在区块内所有交易都是有效的且之前没有被支付的情况下接收这个区块

  

- 节点通过把该区块的哈希值写入下一个区块的方式标识认可该区块

  

因为网络的传播是有延时的，两个节点都在同一高度出块的情况会发生，这两个节点都对外广播自己打包的区块，其他节点以接收到的第一个区块为准，开始接下来的工作，并且也会保存下同一高度的另一个区块。在两到三个区块内就会分出胜负，大家会主动跟随较长的那条链继续出块。

交易不必送达每个节点，区块也容忍丢失，收到下一个区块时，发现丢失会去同步丢失的区块。

### 激励

对打包出块为系统做贡献的节点给予一定的奖励：

1. 新的货币按照固定量稳定的奖励给打包区块的节点，来自系统
2. 从打包的交易中获取手续费，来自其交易的用户

### 回收磁盘空间

使用MerKle Tree减小存储大小，只保留能够确保当前交易推导出根节点哈希的最小节点数。

### 简化的支付验证

用户可以运行一个全节点，同步整个系统中的数据，和一系列的轻节点，当轻节点需要进行交易验证时，可以通过全节点中给该交易打时间戳的区块的默克尔分支进行确认，只要能在默克尔分支中找到对应的位置，说明这笔交易是被大家认可的。但这需要全节点是个诚实的节点。

### 合并和分割交易额

一笔交易将接受多个输入，它们来自之前的交易。两个输出，一个做为输出，一个做为找零。以此减少交易的数量。

### 隐私

传统模型：每个人的身份由一个可信第三方认证，然后通过第三方进行交易，可信机构公布交易结果，帮用户守护隐私。

新的思考：保持公钥的匿名，别人只能看到 coin 被从一个账户转移到另一个账户，并且可以通过公钥来验证是否是对应的账户，但是不能将交易关联到某个人。

### 计算

关于攻击者试图生成一条笔诚实链更快的数学分析。

### 总结

- 通过数字签名货币体系，去除了可信任的第三方机构
- 通过哈希指针确定整个系统的交易历史
- 通过工作量证明和激励保证系统持续且安全的运行